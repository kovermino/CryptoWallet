# 암호화폐 지갑 API

## 요구사항
* 지갑 생성
* 지갑 ETH 잔액 조회
* 입금 이벤트 감지
* 출금

## 작업 현황
### 1. 지갑 생성
- POST /api/wallet
- 아이디와 비밀번호를 입력으로 받아 해당 아이디, 비밀번호로 접근가능한 지갑의 주소와 개인키를 반환
- (질문) 지갑 생성시 이더리움 네트워크와 통신해야 하는지? -> 안해도 된다: web3j를 통해 주소와 개인키를 생성하면 되는 것 같음

### 2. 지갑 ETH 잔액 조회
- GET /api/wallet/balance
- 지갑 주소를 입력으로 받아 현재 데이터베이스에 저장된 잔액을 조회
- 지갑을 생성한 시점에는 잔액이 0이고, 이후에 입금 이벤트가 감지되면 잔액이 갱신되는 형태로 구현

### 3. ETH 입금 이벤트 감지
- (질문) 입금 이벤트는 어떻게 감지하나 callback 등록이 가능한가? -> 여러 가지 구현 방법이 있겠지만 polling을 한 가지 예로 힌트 주심
- 그럼 이더리움 네트워크를 (5초 마다) polling
- <현재 관리되고 있는 지갑 잔액들의 마지막 업데이트 블록 번호 중 가장 작은 번호> ~ <가장 최근에 추가된 블록 번호>까지의 transaction 정보를 조회하여 파싱
- 파싱된 트랜잭션 정보들을 토대로 잔액 갱신 및 트랜잭션 정보 저장(기존에 저장되었던 트랜잭션의 경우,txHash + 거래타입을 통해 알 수 있음,상태정보 업데이트)

#### 트랜잭션 상태(TransactionStatus)
- `Pending` : 트랜잭션을 발생시켰지만 아직 블록에 채굴이 되지 않은 상태(이건 출금과 관련된 상태인듯?)
- `Mined`  : 트랜잭션이 블록에 채굴된 상태
- `Confirmed` : 트랜잭션이 블록에 채굴된 뒤 12개의 블록이 더 채굴되어서 트랜잭션 상태 변화가 완결된 상태

#### 입금 감지 flow
1) 지갑 잔액은 마지막 반영된 블록의 번호를 갖는다.
2) 매 5초마다 지갑에 일어난 트랜잭션을 갱신한다.
- 지갑 주소를 전부 불러온다
- 갱신된 블록 번호가 가장 낮은 지갑의 블록 번호를 알아낸다
- 최신 블록부터 그 블록까지의 트랜잭션 정보를 이더리움 네트워크에서 조회한다
- 조회된 트랜잭션 정보를 순회하면서 지갑별 트랜잭션 리스트를 생성한다
- 잔액 정보를 갱신하고 트랜잭션을 데이터베이스에 삽입한다

### 4. 출금 (작업 전)
- web3j에 특정 주소에서 다른 주소로 transfer하는 메서드가 있는지 확인하고 flow 설계 필요..

## 남은 작업
- 입금 감지 동작 검증
- 출금 flow 설계 및 구현
- docker-compose 구성 (현재는 H2를 기반으로 동작 중)

## 고민 points
- 지갑의 address는 겹치는 일이 없을지? -> 아마 확률적으로 희박할 것 같은 느낌인데 맞을지 -> 현재처럼 형식에 맞는 주소만 생성하면 되는게 맞나?
- 입금 감지의 경우에는 schedule job으로 polling해서 거래내역을 토대로 잔액을 갱신하는데, schedule job이 잘 동작한다면 각 작업마다 읽어들이는 transaction의 양은 적을 것이라는 가정 하에 개발 -> 그런데 관리하는 지갑의 양이 많아지면? 트랜잭션 읽는 작업에 소요되는 시간은 비슷할지언정 update에 걸리는 시간이 길어질지도.. -> 또는 특정 지갑의 마지막 업데이트 블록 번호가 outlier 로 작으면 그 지갑 때문에 그 노드까지의 전체 transaction을 조회하는 시간이 길어져 병목이 생길것임
- 트랜잭션 발생(Pending)과 채굴(Mined) 상태가 나누어져 있는 이유는 뭘까? -> 아마 이더리움 네트워크에 거래를 발생시킨 이후에 실제로 블록에 거래가 기록된 상태로 조회되는 시점 사이에 delay가 있을 것 같음
